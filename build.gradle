buildscript {
    repositories {
        mavenCentral()
        mavenLocal()
    }
}

plugins {
  id 'java-library'
  id 'maven-publish'
  id 'com.github.johnrengelman.shadow' version '4.0.4'
  id 'org.ajoberstar.grgit' version '3.1.1'
}

apply from: "dependencies.gradle"

import org.ajoberstar.grgit.Grgit

if (System.getenv('BUILD_NUMBER') != null) {
    version += ".${System.getenv('BUILD_NUMBER')}"
} else if (new File(projectDir, '.git').exists()) {
    def repo = Grgit.open(currentDir: project.rootDir)
    version += ".${repo.log().find().abbreviatedId}"
} else {
    version += ".CUSTOM"
}

allprojects {
    apply plugin: 'java-library'
    apply plugin: 'maven-publish'
    apply plugin: 'com.github.johnrengelman.shadow'

    archivesBaseName = "ChatMux"
    group = 'com.tterrag.chatmux'
    description = "Chat multiplexer for twitch, mixer, and discord."
    sourceCompatibility = 1.8
    targetCompatibility = 1.8
    
    version = rootProject.version
        
    repositories {
        mavenLocal()
        mavenCentral()
        jcenter() 
        maven { url 'https://jitpack.io' }
        maven { url 'https://repo.spring.io/milestone' }
    }

	dependencies {
		api platform(libs.reactorBom)
	}

    tasks.withType(JavaCompile) {
        options.encoding = 'UTF-8'
    }
    
    publishing {
		repositories {
			if (project.hasProperty('mavendir')) {
				maven { url mavendir }
			}
		}
	}
}

subprojects {
	apply plugin: 'maven-publish'
	
    archivesBaseName = "ChatMux-$project.name"
        
    task sourcesJar(type: Jar) {
        classifier = 'sources'
        from sourceSets.main.allSource
    }
    
    artifacts {
        archives sourcesJar
    }

	configurations {
		proj.extendsFrom implementation
		proj.transitive = false
		ec.extendsFrom compileOnly
	}

	apply plugin: 'eclipse'

	eclipse {
		classpath {
			plusConfigurations += [ configurations.ec ]
		}
	}

    build.dependsOn sourcesJar
    
	shadowJar {
		enabled = false
		configurations = [project.configurations.runtimeClasspath]
		mergeServiceFiles()
		
	}
    
    task genFactoryPath {
        doFirst {
            file('.factorypath').withWriter {
                new groovy.xml.MarkupBuilder(it).'factorypath' {
                    configurations.annotationProcessor.each { dep ->
                        factorypathentry(
                            kind:'EXTJAR',
                            id:dep.absolutePath,
                            enabled:true,
                            runInBatchMode:false
                        )
                    }
                }
            }
        }
    }
    
    publishing {
    	tasks.publish.dependsOn 'build'
    	publications {
        	"$project.name"(MavenPublication) {
        		artifactId archivesBaseName
            	from components.java
            	
            	artifact sourcesJar
        	}
    	}
    }
}

subprojects.each { subproject -> evaluationDependsOn( subproject.path ) }

def mergeFiles() {
    def serviceMap = [:].withDefault{ k -> new StringBuilder() }
    
    subprojects.each { subproject ->
        new File(subproject.sourceSets.main.output.classesDirs.getSingleFile(), 'META-INF/services').listFiles().each { file ->
            serviceMap[file.getName()].append(file.text)
        }
    }
    
    serviceMap.each { k, v -> 
        File output = new File(project.sourceSets.main.output.classesDirs.getSingleFile(), 'META-INF/services/' + k)
        output.getParentFile().mkdirs()
        output << v
    }
    
    File logbackXml = new File(project.sourceSets.main.output.resourcesDir, 'logback.xml')
    logbackXml.getParentFile().mkdirs()
    logbackXml << '<configuration>\n'
    subprojects.each { subproject ->
    	File subprojectLogbackXml = new File(subproject.sourceSets.main.output.resourcesDir, 'logback.xml');
    	if (subprojectLogbackXml.exists()) logbackXml << subprojectLogbackXml.text.replaceAll('</?subconfig>', '')
    }
    logbackXml << '\n</configuration>'
    
    File extensionsIndex = new File(project.sourceSets.main.output.classesDirs.getSingleFile(), 'META-INF/extensions.idx')
    extensionsIndex.getParentFile().mkdirs()
    subprojects.each { subproject ->
    	File subprojectIndex = new File(subproject.sourceSets.main.output.classesDirs.getSingleFile(), 'META-INF/extensions.idx') 
    	if (subprojectIndex.exists()) extensionsIndex << subprojectIndex.text.replaceAll('#[^\\n]+\\n', '')
   	}
}

// Collect all sources from the modules and merge them into the "main" jar.
jar.dependsOn subprojects.tasks['classes']
jar {
    doFirst { mergeFiles() }
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    subprojects.each { subproject ->
        from subproject.sourceSets.main.output.classesDirs
        from subproject.sourceSets.main.output.resourcesDir
    }
    manifest {
        attributes 'Main-Class': 'com.tterrag.chatmux.Main'
    }
}

// Shadow doesn't help here, so do it all manually
// Copy contents of all dependencies of all subprojects into a -all jar, excluding some unnecessary things (and ourselves).
task allJar(type: Jar, dependsOn: subprojects.tasks['classes']) {
    doFirst { mergeFiles() }
    classifier = 'all'
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    from project.sourceSets.main.output
    subprojects.each { subproject -> 
        from subproject.sourceSets.main.output.classesDirs
        from subproject.sourceSets.main.output.resourcesDir
        dependsOn subproject.configurations.runtimeClasspath
        // Including our own jars overwrites the merged service file, and skip lombok
        from { subproject.configurations.runtimeClasspath.findAll { it.name.endsWith('jar') && !it.name.startsWith('ChatMux') && !it.name.contains('lombok') }.collect { zipTree(it) }}
    }
    // Useless metadata
    exclude 'META-INF/maven/**'
    manifest {
        attributes 'Main-Class': 'com.tterrag.chatmux.Main'
    }
}

task mergedSourcesJar(type: Jar) {
    classifier = 'sources'
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    subprojects.each { subproject ->
        from subproject.sourceSets.main.allSource
    }
}

// Copy all the subproject jars to build/libs
task copyJars(type: Copy, dependsOn: subprojects.tasks['build']) {
    from subprojects.collect { it.tasks.withType(Jar) }
    into "$buildDir/libs"
}

project.build.dependsOn allJar, mergedSourcesJar, copyJars

publishing {
    tasks.publish.dependsOn 'build'
    publications {
        mavenJava(MavenPublication) {
            artifact allJar
            artifact mergedSourcesJar
        }
    }
}